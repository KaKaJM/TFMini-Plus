  /*  File Name: TFMiniPlus.cpp
 *  Described: Library for testing the Benewake TFMini Plus Lidar sensor
 *             Because various TFMini Arduino Libraries are not compatible with the TFMini Plus
 *  Developer: Bud Ryerson
 *  Inception: 31 JAN 2019
 *
 *  Modified Arduino library for TFMini by Peter Jansen (December 11/2017)
*/

#include <TFMPlus.h>

// Constructor
  TFMPlus::TFMPlus(){}
  TFMPlus::~TFMPlus(){}

boolean TFMPlus::begin(Stream* _streamPtr)
{
  // Store reference to stream/serial object
  streamPtr = _streamPtr;

  // Clear state
  distance = -1;
  strength = -1;
  temperature = -1;
  state = READY;

  // Set standard output mode
  //setStandardOutputMode();

  return true;
}

void TFMPlus::setDebugMode( bool mode)
{
  debugMode = mode;
}

// clear data input buffer
void TFMPlus::flushBuffer()
{
  int numChars = 0;
  while( streamPtr -> available())
  {
    streamPtr -> read();
    numChars++;
  }
}

// Try to read one byte and return status
bool TFMPlus::readData( uint8_t &rdByte)
{
  for( uint8_t rdTimer = 0; rdTimer < 30; ++rdTimer)
  {
    if( streamPtr -> available())       // If data is availabele...
    {
      rdByte = streamPtr -> read();     // read one byte...
      return true;                      // and return "true".
    }
  }

  // If data repeatedly not available then
  // report device serial connection error
  state = NO_SERIAL;
 
  return false;    // and return "false".
}

// Sum up all but the last byte of data and
// compare low byte of Sum with last byte of data
bool TFMPlus::checkSum( uint8_t *data, uint8_t dataLen)
{
    uint16_t  Sum = 0;
    for( uint8_t i = 0; i < dataLen; i++)  // Add all but last byte of data.
    {
      Sum += data[ i];
    }
     
    if( (uint8_t)Sum == data[ dataLen])    // If the Low byte of Sum matches...
    {                                      // the last byte of data...
      state = READY;                       // set Ready state...
      return true;                         // and return true.
    }
    else
    {
      // Serial.print( "Checksum error");
       state = BAD_CHECKSUM;                // Else set Error state...
       return false;                        // and return false.
    }
}

// Print the Hex value of each bytye of data
void TFMPlus::printData( uint8_t *data, uint8_t dataLen)
{
  for( uint8_t i = 0; i < dataLen; i++)
  {
    printf(" %02x", data[ i]);
  }
}

void TFMPlus::writeData( uint8_t *data, uint8_t dataLen)
{
  for( uint8_t i = 0; i < dataLen; i++)
  {
    streamPtr -> write( data[ i]);
  }
}

// Public: The main function to measure distance.
bool TFMPlus::getData( uint16_t& data, uint16_t& flux, uint16_t& temp)
{
  int numMeasurementAttempts = 0;
  // Loop until takeMeasurement returns a "0" or
  // break if too many measurements are atteempted
  while( 1)
  {
    if( takeMeasurement() == 0)
    {
      data = distance;
      flux = strength;
      temp = temperature;
      state = READY;
      return true;
    }
    else
    {
      ++numMeasurementAttempts;
    }
    if( numMeasurementAttempts > MAX_MEASUREMENT_ATTEMPTS)
    {
      state = TOO_MANY_TRIES;
    }

    if (TFMPLUS_DEBUGMODE == 1)
    {
      Serial.print("TFMPlus Error: ");
      if( state == NO_SERIAL)                Serial.println( "NO_SERIAL");
      else if( state == NO_HEADER_DETECTED)  Serial.println( "NO_HEADER_DETECTED");
      else if( state == BAD_CHECKSUM)        Serial.println( "BAD_CHECKSUM");
      else if( state == TOO_MANY_TRIES)      Serial.println( "TOO_MANY_TRIES");
    }

    if( state == TOO_MANY_TRIES)
    {
      dist = -1;
      flux = -1;
      temp = -1;
      state = READY;
      return false;
     }
  }
}


// Set to "standard" output mode: 9-byte, centimeter range
void TFMPlus::setStandardOutputMode()
{
  // Code for Standard Output Mode command
  uint8_t command[ 5] = { 0x5A, 0x05, 0x05, 0x01, 0x65};
  writeData( command, 5);
  delay(100);
}


void TFMPlus::getFirmwareVersion()
{
  // Code for Obtain Frimware Version command  
  uint8_t command[ 4] = { 0x5A, 0x04, 0x01, 0x5F};
  
  flushBuffer();               // flush serial input buffer
  writeData( command, 4);      // send command data to the device

  uint8_t verDat[ 7];

  while( streamPtr -> available() < 7);
  for( int i = 0; i < 7; i++)
  {
    verDat[ i] = streamPtr -> read();
  }

  if( ( verDat[ 0] == 0x5A) && ( verDat[ 1] == 0x07))  // If header detected...
  {
    if( checkSum( verDat, ( sizeof( verDat) - 1)))
    {
      printf( "Firmware Version: %1u.%1u.%1u\r\n", verDat[5], verDat[4], verDat[3]);
      return;
    }
    else Serial.print( "BAD VERSION CHECKSUM");
  }
  else Serial.print( "BAD VERSION HEADER ");
  printData( verDat, 4);
  Serial.println();
}



// Private: Handles the low-level bits of communicating with the TFMini, and detecting some communication errors.
int TFMPlus::takeMeasurement()
{
  int numCharsRead = 0;
  uint8_t frame[ TFMPLUS_FRAME_SIZE];
  frame[ 0] = 0;

  // Step 1:
  // Read serial stream until the TFMPlus header sequence
  // or timeout from reading too many characters.
  // If no data is available, the call will wait data is available,
  // a timer expires, or some other error occurs.
  while( 1)
  {
    if( !readData( frame[ 1])) return -1;
    if( (frame[ 0] == 0x59) && (frame[ 1] == 0x59))  // If header detected...
    {
      break;                 // break to finish reading the frame.
    }
    else                     // If not 0x59 in first two positions...
    {
      frame[ 0] = frame[ 1]; // move 2nd byte to 1st pos and continue reading.
      numCharsRead++;        // Advance character counter.
    }


    // Error detection:
    // If read more than MAXBYTES without a frame header, then
    // likely issue with Serial connection. Timeout and throw an error.
    if( numCharsRead > MAX_BYTES_BEFORE_HEADER)
    {
      state = NO_HEADER_DETECTED;
      Serial.print("No Header ");
      return -1;
    }
  }

  // Step 2:
  // Read rest of data frame from the TFMini Plus
  // return error if serial buffer runs out.
  for( int i = 2; i < TFMPLUS_FRAME_SIZE; i++)
  {
    if( !readData( frame[ i])) return -1;
  }

  // Step 2A: Compare checksum
  // Last byte in the frame is an 8-bit checksum
  if( !checkSum( frame, ( sizeof(frame) - 1))) return -1;

  // Step 3: Interpret frame
  distance  =   frame[ 2] + ( frame[ 3] << 8);
  strength  =   frame[ 4] + ( frame[ 5] << 8);
  temperature = frame[ 6] + ( frame[ 7] << 8);

  state = MEASUREMENT_OK;

  return 0;    // Return success
}

